[{"id":"0bca2959d942e928","type":"tab","label":"Titan Time Sync","disabled":false,"info":"","env":[]},{"id":"e14b756916276f20","type":"inject","z":"0bca2959d942e928","name":"HEX","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"5e708000e21804d3087d823b8b","payloadType":"str","x":250,"y":200,"wires":[["508d80a10916b038"]]},{"id":"80a09212b6e2be73","type":"debug","z":"0bca2959d942e928","name":"decoded date","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":660,"y":200,"wires":[]},{"id":"508d80a10916b038","type":"function","z":"0bca2959d942e928","name":"decode date","func":"// Node-RED Function Node Code - Decode Tecom UDP Packet to Date/Time\n// Updated with correct decoding algorithm and month disambiguation\n// Supports years 1990-2053 (64-year range - hardware limitation)\n\n// Calculate month offset for date byte decoding\n// Months 1-7: offset = month * 32\n// Months 8-12: offset = (month - 8) * 32\nfunction getMonthOffset(month) {\n    if (month >= 1 && month <= 7) {\n        return month * 32;\n    } else if (month >= 8 && month <= 12) {\n        return (month - 8) * 32;\n    }\n    return -1; // Invalid month\n}\n\n// The main function that will be executed by Node-RED\nmsg.payload = decodeUdpPacket(msg.payload);\n\nreturn msg;\n\n/**\n * Decodes a Titan Security V8 Challenger UDP packet string to a human-readable date and time.\n *\n * @param {string} hexString The UDP packet data as a hexadecimal string (e.g., \"5e7080001e18045f4620b3b447\").\n * @returns {string} The decoded date and time in \"DD/MM/YYYY HH:MM:SS AM/PM\" format, or an error message.\n */\nfunction decodeUdpPacket(hexString) {\n    if (typeof hexString !== 'string' || hexString.length < 22) {\n        return \"Error: Invalid UDP packet string format or length.\";\n    }\n\n    // Extract relevant bytes based on the confirmed positions\n    // The string is hex, so each byte is 2 characters.\n    // Packet structure (13 bytes total):\n    // Byte 0: Fixed (0x5e)\n    // Byte 1: Unknown (varies - often 0x70 or 0x60, doesn't affect date/time)\n    // Bytes 2-3: Fixed (0x8000)\n    // Byte 4: Message counter (varies)\n    // Bytes 5-6: Fixed middle constant (0x1804)\n    // Byte 7: DateByte = MonthOffset + Day\n    // Byte 8: ModeByte = (Year - 1990) * 2 + MonthRangeBit, plus seconds parity in bit 1\n    // Byte 9: TimeByte1 = (Minutes % 8) * 32 + (Seconds / 2)\n    // Byte 10: TimeByte2 = Hour * 8 + (Minutes / 8)\n    // Bytes 11-12: CRC-16/MODBUS checksum\n\n    try {\n        const dateByte = parseInt(hexString.substring(14, 16), 16);      // Byte 7\n        const modeByte = parseInt(hexString.substring(16, 18), 16);      // Byte 8\n        const timeByte1 = parseInt(hexString.substring(18, 20), 16);     // Byte 9\n        const timeByte2 = parseInt(hexString.substring(20, 22), 16);     // Byte 10\n\n        // --- Decode Date (Day and Month) ---\n        let day = -1;\n        let month = -1;\n        let possibleMatches = [];\n\n        // Bit 0 of ModeByte indicates month range: 0 = months 1-7, 1 = months 8-12\n        const monthRangeBit = modeByte & 0x01;\n        const isHighMonthRange = monthRangeBit === 1; // true for months 8-12\n\n        // Iterate through all months to find which one matches\n        for (let m = 1; m <= 12; m++) {\n            // Skip months not in the correct range based on bit 0\n            if (isHighMonthRange && m < 8) continue;\n            if (!isHighMonthRange && m >= 8) continue;\n            \n            const offset = getMonthOffset(m);\n            const calculatedDay = dateByte - offset;\n\n            // Validate day is in reasonable range (1-31)\n            if (calculatedDay >= 1 && calculatedDay <= 31) {\n                // Additional validation: check days in month\n                const daysInMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                if (calculatedDay <= daysInMonth[m - 1]) {\n                    possibleMatches.push({ month: m, day: calculatedDay });\n                }\n            }\n        }\n        \n        if (possibleMatches.length > 0) {\n            day = possibleMatches[0].day;\n            month = possibleMatches[0].month;\n        }\n\n        if (day === -1 || month === -1) {\n            return `Error: Could not decode day/month for DateByte: 0x${hexString.substring(14, 16)} (${dateByte})`;\n        }\n\n        // --- Decode Year (from Cycle Byte and ModeByte) ---\n        // Cycle byte (Byte 1): 0x70 for 1990-2053, 0x60 for 2054-2117\n        // ModeByte bits 1-6: ((year - 1990) * 2) % 128 (wraps every 64 years)\n        // Bit 7: 1 if seconds are odd, 0 if even  \n        // Bit 0: 1 for months 8-12, 0 for months 1-7\n        \n        // --- Decode Year ---\n        // Year is encoded in bits 1-7 of ModeByte\n        // Formula: Year = 1990 + floor(ModeByte / 2)\n        // Note: Hardware only supports 1990-2053. Years beyond this wrap around.\n        const year = 1990 + Math.floor(modeByte / 2);\n        \n        // Validate year is within hardware range\n        if (year < 1990 || year > 2053) {\n            return `Error: Decoded year ${year} is out of hardware range (1990-2053). Year may have wrapped.`;\n        }\n\n        // --- Decode Time (Hour, Minutes, Seconds) ---\n        \n        // TimeByte2 = Hour * 8 + (Minutes / 8)\n        const hour24 = Math.floor(timeByte2 / 8);\n        const minutesDiv8 = timeByte2 % 8;\n\n        // TimeByte1 = (Minutes % 8) * 32 + (Seconds / 2)\n        const minutesRem8 = Math.floor(timeByte1 / 32);\n        const sDiv2 = timeByte1 % 32;\n\n        // Reconstruct minutes\n        const minutes = (minutesDiv8 * 8) + minutesRem8;\n\n        // Reconstruct seconds\n        // Bit 7 of ModeByte indicates if seconds are odd (1) or even (0)\n        const secondsParity = (modeByte >> 7) & 0x01; // 0 for even, 1 for odd\n        const seconds = (sDiv2 * 2) + secondsParity;\n\n        // --- Validate decoded values ---\n        if (hour24 < 0 || hour24 > 23) {\n            return `Error: Decoded hour ${hour24} is out of range (0-23)`;\n        }\n        if (minutes < 0 || minutes > 59) {\n            return `Error: Decoded minutes ${minutes} is out of range (0-59)`;\n        }\n        if (seconds < 0 || seconds > 59) {\n            return `Error: Decoded seconds ${seconds} is out of range (0-59)`;\n        }\n\n        // --- Format Output ---\n        const ampm = hour24 >= 12 ? 'PM' : 'AM';\n        const displayHour = hour24 % 12 === 0 ? 12 : hour24 % 12; // Convert 0 to 12 for midnight, 12 stays 12 for noon\n\n        const formattedDate = `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}/${year}`;\n        const formattedTime = `${String(displayHour).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')} ${ampm}`;\n\n        return `${formattedDate} ${formattedTime}`;\n\n    } catch (e) {\n        return `Error decoding packet: ${e.message}`;\n    }\n}\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":450,"y":200,"wires":[["80a09212b6e2be73"]]},{"id":"db8872fb39128fde","type":"inject","z":"0bca2959d942e928","name":"date timestamp","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":240,"y":360,"wires":[["17ca7b6f9f6e7b59","6c2cb38b6f583770"]]},{"id":"17ca7b6f9f6e7b59","type":"function","z":"0bca2959d942e928","name":"encode date","func":"// Node-RED Function Node Code: Encode Date/Time to UDP Packet with DYNAMIC CHECKSUM\n// Updated with proper CRC-16/MODBUS checksum calculation and month disambiguation\n// Supports years 1990-2053 (64-year range - hardware limitation)\n\n// Calculate month offset for date byte encoding\n// Months 1-7: offset = month * 32\n// Months 8-12: offset = (month - 8) * 32\nfunction getMonthOffset(month) {\n    if (month >= 1 && month <= 7) {\n        return month * 32;\n    } else if (month >= 8 && month <= 12) {\n        return (month - 8) * 32;\n    }\n    throw new Error(`Invalid month: ${month}`);\n}\n\n// Fixed parts of the UDP packet\nconst UDP_PREFIX_BASE = \"5e\"; // Byte 0\n// Byte 1 varies (often 0x70 or 0x60) - purpose unknown, doesn't affect date/time\nconst UDP_BYTE1 = \"70\"; // Default value observed in most packets\nconst UDP_SUFFIX = \"8000\"; // Bytes 2-3 \n\n// Byte 4 is a MESSAGE COUNTER - it can be any value and changes with each packet\n// We'll use a simple incrementing counter or random value\n// Initialize counter in flow context to persist across calls\nlet messageCounter = context.get('tecomMessageCounter') || 0;\nmessageCounter = (messageCounter + 1) % 256;  // Increment and wrap at 256\ncontext.set('tecomMessageCounter', messageCounter);\n\nconst UDP_MIDDLE_CONSTANT = \"1804\"; // Bytes 5-6 appear constant in the middle section.\n\n/**\n * Calculate CRC-16/MODBUS checksum for Tecom packets\n * The checksum is chosen so that the CRC of the full packet equals 0x37b1\n */\nfunction calculateTecomChecksum(packetDataHex) {\n    const TARGET_CRC = 0x37b1;  // Magic constant - all valid Tecom packets CRC to this\n    \n    function crc16_modbus_byte(crc, byte) {\n        const poly = 0xA001;  // MODBUS polynomial (LSB-first)\n        crc ^= byte;\n        for (let i = 0; i < 8; i++) {\n            if (crc & 0x0001) {\n                crc = (crc >> 1) ^ poly;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n        return crc & 0xFFFF;\n    }\n    \n    function crc16_modbus(data, init = 0xFFFF) {\n        let crc = init;\n        for (let byte of data) {\n            crc = crc16_modbus_byte(crc, byte);\n        }\n        return crc & 0xFFFF;\n    }\n    \n    // Calculate CRC of the packet data (without checksum bytes)\n    const dataBytes = Buffer.from(packetDataHex, 'hex');\n    const crcBeforeChecksum = crc16_modbus(dataBytes);\n    \n    // Find the 2 checksum bytes that make the full packet CRC to TARGET_CRC\n    for (let byte1 = 0; byte1 <= 0xFF; byte1++) {\n        for (let byte2 = 0; byte2 <= 0xFF; byte2++) {\n            let testCrc = crcBeforeChecksum;\n            testCrc = crc16_modbus_byte(testCrc, byte1);\n            testCrc = crc16_modbus_byte(testCrc, byte2);\n            \n            if (testCrc === TARGET_CRC) {\n                return byte1.toString(16).padStart(2, '0') + byte2.toString(16).padStart(2, '0');\n            }\n        }\n    }\n    \n    throw new Error(\"Could not calculate valid checksum!\");\n}\n\n// The main function that will be executed by Node-RED\nlet targetDate = new Date(); // Default to current time\n\n// Allow input to override the current time:\n// - If msg.payload is a valid Date object, use it.\n// - If msg.payload is null, use current time (standard inject node behavior).\n// - If msg.payload is a string, try to parse it as a date.\nif (msg.payload && msg.payload instanceof Date) {\n    targetDate = msg.payload;\n} else if (typeof msg.payload === 'string') {\n    const parsedDate = new Date(msg.payload);\n    if (!isNaN(parsedDate.getTime())) { // Check if successfully parsed as a valid date\n        targetDate = parsedDate;\n    }\n    // If not a valid date string, it will default to current time as per initial targetDate setup.\n}\n\ntry {\n    msg.payload = encodeUdpPacket(targetDate);\n} catch (e) {\n    msg.payload = `Error encoding packet: ${e.message}`;\n    node.error(e); // Log the error in Node-RED debug tab for better debugging\n}\n\nreturn msg;\n\n/**\n * Encodes a Date object into a Titan Security V8 Challenger UDP packet hex string.\n *\n * @param {Date} dateTime The Date object to encode.\n * @returns {string} The encoded UDP packet as a hexadecimal string.\n * @throws {Error} If the date or time components are out of range for encoding.\n */\nfunction encodeUdpPacket(dateTime) {\n    const year = dateTime.getFullYear();\n    const month = dateTime.getMonth() + 1; // getMonth() is 0-indexed\n    const day = dateTime.getDate();\n    const hour = dateTime.getHours();\n    const minutes = dateTime.getMinutes();\n    const seconds = dateTime.getSeconds();\n    \n    // Validate year range (hardware limitation: only supports 1990-2053)\n    if (year < 1990 || year > 2053) {\n        throw new Error(`Year ${year} not supported. Valid range: 1990-2053 (hardware limitation)`);\n    }\n\n    // --- 1. Encode DateByte (Byte 7) ---\n    // FORMULA: dateByte = monthOffset + day\n    const monthOffset = getMonthOffset(month);\n    const dateByte1Like = monthOffset + day;\n    if (dateByte1Like < 0 || dateByte1Like > 255) {\n        throw new Error(`Calculated DateByte1_like (${dateByte1Like}) for Day ${day} and Month ${month} is out of byte range (0-255).`);\n    }\n\n    // --- 2. Encode ModeByte (Byte 8) ---\n    // This byte encodes BOTH year and month range:\n    // Bits 1-7: (year - 1990) (NOT multiplied by 2 - the *2 happens when combined with bit 0)\n    // Bit 0: 1 for months 8-12, 0 for months 1-7\n    // Formula: ModeByte = (year - 1990) * 2 + monthRangeBit\n    \n    const yearOffset = year - 1990;\n    let modeByte = yearOffset * 2;\n    \n    // Set bit 0 if month is in high range (8-12)\n    if (month >= 8) {\n        modeByte |= 0x01;\n    }\n    \n    // Note: Bit 1 is used for seconds parity in the DECODING, but appears NOT to be set during encoding\n    // The decoder uses: seconds = (sDiv2 * 2) + ((modeByte >> 1) & 0x01)\n    // But in real captures, this bit doesn't correlate with seconds parity\n    // We'll leave it as-is (part of year*2)\n\n    // --- 3. Encode TimeByte1 (Byte 9) ---\n    const minutesRem8 = minutes % 8;\n    const sDiv2 = Math.floor(seconds / 2); // Integer division\n    const timeByte1 = (minutesRem8 * 32) + sDiv2;\n    if (timeByte1 < 0 || timeByte1 > 255) {\n         throw new Error(`Calculated TimeByte1 (${timeByte1}) is out of byte range (0-255).`);\n    }\n\n    // --- 4. Encode TimeByte2 (Byte 10) ---\n    const minutesDiv8 = Math.floor(minutes / 8); // Integer division\n    const timeByte2 = (hour * 8) + minutesDiv8;\n    if (timeByte2 < 0 || timeByte2 > 255) {\n        throw new Error(`Calculated TimeByte2 (${timeByte2}) is out of byte range (0-255).`);\n    }\n\n    // --- 5. Assemble the packet data (without checksum) ---\n    // Byte 4 is the message counter (already set at top of function)\n    const messageCounterHex = messageCounter.toString(16).padStart(2, '0');\n    \n    // Convert calculated byte values to 2-character hexadecimal strings\n    const dateByte1LikeHex = dateByte1Like.toString(16).padStart(2, '0');\n    const modeByteHex = modeByte.toString(16).padStart(2, '0');\n    const timeByte1Hex = timeByte1.toString(16).padStart(2, '0');\n    const timeByte2Hex = timeByte2.toString(16).padStart(2, '0');\n\n    const packetDataWithoutChecksum = UDP_PREFIX_BASE + UDP_BYTE1 + UDP_SUFFIX +\n                                      messageCounterHex + UDP_MIDDLE_CONSTANT +\n                                      dateByte1LikeHex +\n                                      modeByteHex +\n                                      timeByte1Hex +\n                                      timeByte2Hex;\n\n    // --- Calculate dynamic checksum ---\n    const checksum = calculateTecomChecksum(packetDataWithoutChecksum);\n    \n    // --- Assemble full packet ---\n    const fullPacket = packetDataWithoutChecksum + checksum;\n\n    return fullPacket;\n}\n","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":450,"y":360,"wires":[["8f56442d8299f3bd","508d80a10916b038"]]},{"id":"8f56442d8299f3bd","type":"debug","z":"0bca2959d942e928","name":"encoded date","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":640,"y":360,"wires":[]},{"id":"6c2cb38b6f583770","type":"debug","z":"0bca2959d942e928","name":"timestamp","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":410,"y":480,"wires":[]},{"id":"113c8587d2247296","type":"inject","z":"0bca2959d942e928","name":"date string","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"2053-06-01T16:04:00","payloadType":"str","x":180,"y":480,"wires":[["17ca7b6f9f6e7b59"]]},{"id":"059e3fd74184443b","type":"buffer-parser","z":"0bca2959d942e928","name":"","data":"payload","dataType":"msg","specification":"spec","specificationType":"ui","items":[{"type":"int16be","name":"item1","offset":0,"length":1,"offsetbit":0,"scale":"1","mask":""}],"swap1":"","swap2":"","swap3":"","swap1Type":"swap","swap2Type":"swap","swap3Type":"swap","msgProperty":"payload","msgPropertyType":"str","resultType":"buffer","resultTypeType":"return","multipleResult":false,"fanOutMultipleResult":false,"setTopic":true,"outputs":1,"x":450,"y":120,"wires":[[]]},{"id":"9e669a79a54b9e9c","type":"inject","z":"0bca2959d942e928","name":"Poll time","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"5e7080001d250118633a","payloadType":"str","x":260,"y":120,"wires":[["059e3fd74184443b"]]},{"id":"9ded2cbf31f1a58d","type":"udp out","z":"0bca2959d942e928","name":"","addr":"192.168.1.20","iface":"","port":"3001","ipv":"udp4","outport":"","base64":false,"multicast":"false","x":670,"y":120,"wires":[]},{"id":"f8c81b2b67cf0b15","type":"global-config","env":[],"modules":{"node-red-contrib-buffer-parser":"3.2.2"}}]